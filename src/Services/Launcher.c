/* Launcher.c generated by valac 0.20.1, the Vala compiler
 * generated from Launcher.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <clutter/clutter.h>
#include <glib/gi18n-lib.h>
#include <float.h>
#include <math.h>
#include <stdio.h>


#define TYPE_SERVICE (service_get_type ())
#define SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SERVICE, Service))
#define SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SERVICE, ServiceClass))
#define IS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SERVICE))
#define IS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SERVICE))
#define SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SERVICE, ServiceClass))

typedef struct _Service Service;
typedef struct _ServiceClass ServiceClass;
typedef struct _ServicePrivate ServicePrivate;

#define TYPE_LAUNCHER (launcher_get_type ())
#define LAUNCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LAUNCHER, Launcher))
#define LAUNCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LAUNCHER, LauncherClass))
#define IS_LAUNCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LAUNCHER))
#define IS_LAUNCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LAUNCHER))
#define LAUNCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LAUNCHER, LauncherClass))

typedef struct _Launcher Launcher;
typedef struct _LauncherClass LauncherClass;
typedef struct _LauncherPrivate LauncherPrivate;

#define TYPE_SHADOWED_LABEL (shadowed_label_get_type ())
#define SHADOWED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SHADOWED_LABEL, ShadowedLabel))
#define SHADOWED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SHADOWED_LABEL, ShadowedLabelClass))
#define IS_SHADOWED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SHADOWED_LABEL))
#define IS_SHADOWED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SHADOWED_LABEL))
#define SHADOWED_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SHADOWED_LABEL, ShadowedLabelClass))

typedef struct _ShadowedLabel ShadowedLabel;
typedef struct _ShadowedLabelClass ShadowedLabelClass;
typedef struct _Block2Data Block2Data;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _Service {
	ClutterActor parent_instance;
	ServicePrivate * priv;
};

struct _ServiceClass {
	ClutterActorClass parent_class;
	void (*create) (Service* self);
	gboolean (*update) (Service* self);
};

struct _Launcher {
	Service parent_instance;
	LauncherPrivate * priv;
};

struct _LauncherClass {
	ServiceClass parent_class;
};

struct _Block2Data {
	int _ref_count_;
	Launcher * self;
	ShadowedLabel* apps_label;
	ShadowedLabel* apps_list;
};


static gpointer launcher_parent_class = NULL;

#define apps_string "Chrome\nFiles\nTerminal\nText Editor\nProcessing\nPython\nArduino"
GType service_get_type (void) G_GNUC_CONST;
GType launcher_get_type (void) G_GNUC_CONST;
enum  {
	LAUNCHER_DUMMY_PROPERTY
};
Launcher* launcher_new (void);
Launcher* launcher_construct (GType object_type);
Service* service_construct (GType object_type, const gchar* _id);
gboolean service_load (Service* self);
static void launcher_real_create (Service* base);
GType shadowed_label_get_type (void) G_GNUC_CONST;
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
#define textcolor "black"
ShadowedLabel* shadowed_label_new (const gchar* _label);
ShadowedLabel* shadowed_label_construct (GType object_type, const gchar* _label);
static gboolean __lambda17_ (Block2Data* _data2_, ClutterButtonEvent* e);
static gboolean ___lambda17__clutter_actor_button_release_event (ClutterActor* _sender, ClutterButtonEvent* event, gpointer self);
static gboolean launcher_real_update (Service* base);

const gchar* apps_term[7] = {"chromium-browser", "pantheon-files", "x-terminal-emulator", "gedit", "~/Programming/processing-2.0.3/processing", "idle", "~/Programming/arduino-1.5.5/arduino"};

Launcher* launcher_construct (GType object_type) {
	Launcher * self = NULL;
	self = (Launcher*) service_construct (object_type, "launcher");
	service_load ((Service*) self);
	return self;
}


Launcher* launcher_new (void) {
	return launcher_construct (TYPE_LAUNCHER);
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		Launcher * self;
		self = _data2_->self;
		_g_object_unref0 (_data2_->apps_list);
		_g_object_unref0 (_data2_->apps_label);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static gboolean __lambda17_ (Block2Data* _data2_, ClutterButtonEvent* e) {
	Launcher * self;
	gboolean result = FALSE;
	gfloat root_x = 0.0F;
	gfloat root_y = 0.0F;
	gfloat _tmp0_ = 0.0F;
	gfloat _tmp1_ = 0.0F;
	ClutterButtonEvent _tmp2_;
	gfloat _tmp3_;
	gfloat _tmp4_;
	gfloat _tmp5_;
	gint item;
	GError * _inner_error_ = NULL;
	self = _data2_->self;
	g_return_val_if_fail (e != NULL, FALSE);
	clutter_actor_get_transformed_position ((ClutterActor*) _data2_->apps_list, &_tmp0_, &_tmp1_);
	root_x = _tmp0_;
	root_y = _tmp1_;
	_tmp2_ = *e;
	_tmp3_ = _tmp2_.y;
	_tmp4_ = clutter_actor_get_height ((ClutterActor*) _data2_->apps_label);
	_tmp5_ = _tmp4_;
	item = (gint) ((_tmp3_ - root_y) / (_tmp5_ - 4));
	{
		const gchar* _tmp6_;
		_tmp6_ = apps_term[item];
		g_spawn_command_line_async (_tmp6_, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_SPAWN_ERROR) {
				goto __catch1_g_spawn_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	goto __finally1;
	__catch1_g_spawn_error:
	{
		GError* e = NULL;
		FILE* _tmp7_;
		GError* _tmp8_;
		const gchar* _tmp9_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = stdout;
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		fprintf (_tmp7_, "Error: %s\n", _tmp9_);
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


static gboolean ___lambda17__clutter_actor_button_release_event (ClutterActor* _sender, ClutterButtonEvent* event, gpointer self) {
	gboolean result;
	result = __lambda17_ (self, event);
	return result;
}


static void launcher_real_create (Service* base) {
	Launcher * self;
	Block2Data* _data2_;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	ShadowedLabel* _tmp5_;
	ShadowedLabel* _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	ShadowedLabel* _tmp11_;
	ShadowedLabel* _tmp12_;
	gfloat _tmp13_;
	gfloat _tmp14_;
	self = (Launcher*) base;
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = g_object_ref (self);
	_tmp0_ = _ ("Applications");
	_tmp1_ = g_strdup_printf ("' font='20' face='Raleway'>%s</span>", _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("<span color='" textcolor, _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = shadowed_label_new (_tmp4_);
	g_object_ref_sink (_tmp5_);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	_data2_->apps_label = _tmp6_;
	_tmp7_ = g_strdup_printf ("' font='20' face='Raleway'>%s</span>", apps_string);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strconcat ("<span color='" textcolor, _tmp8_, NULL);
	_tmp10_ = _tmp9_;
	_tmp11_ = shadowed_label_new (_tmp10_);
	g_object_ref_sink (_tmp11_);
	_tmp12_ = _tmp11_;
	_g_free0 (_tmp10_);
	_g_free0 (_tmp8_);
	_data2_->apps_list = _tmp12_;
	_tmp13_ = clutter_actor_get_height ((ClutterActor*) _data2_->apps_label);
	_tmp14_ = _tmp13_;
	clutter_actor_set_y ((ClutterActor*) _data2_->apps_list, _tmp14_ + 12);
	clutter_actor_set_x ((ClutterActor*) _data2_->apps_list, (gfloat) 12);
	clutter_actor_add_child ((ClutterActor*) self, (ClutterActor*) _data2_->apps_label);
	clutter_actor_add_child ((ClutterActor*) self, (ClutterActor*) _data2_->apps_list);
	clutter_actor_set_reactive ((ClutterActor*) _data2_->apps_list, TRUE);
	g_signal_connect_data ((ClutterActor*) _data2_->apps_list, "button-release-event", (GCallback) ___lambda17__clutter_actor_button_release_event, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	block2_data_unref (_data2_);
	_data2_ = NULL;
}


static gboolean launcher_real_update (Service* base) {
	Launcher * self;
	gboolean result = FALSE;
	self = (Launcher*) base;
	result = TRUE;
	return result;
}


static void launcher_class_init (LauncherClass * klass) {
	launcher_parent_class = g_type_class_peek_parent (klass);
	SERVICE_CLASS (klass)->create = launcher_real_create;
	SERVICE_CLASS (klass)->update = launcher_real_update;
}


static void launcher_instance_init (Launcher * self) {
}


GType launcher_get_type (void) {
	static volatile gsize launcher_type_id__volatile = 0;
	if (g_once_init_enter (&launcher_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LauncherClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) launcher_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Launcher), 0, (GInstanceInitFunc) launcher_instance_init, NULL };
		GType launcher_type_id;
		launcher_type_id = g_type_register_static (TYPE_SERVICE, "Launcher", &g_define_type_info, 0);
		g_once_init_leave (&launcher_type_id__volatile, launcher_type_id);
	}
	return launcher_type_id__volatile;
}



